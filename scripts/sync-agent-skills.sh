#!/usr/bin/env bash
set -euo pipefail

MODE="apply"
if [[ "${1:-}" == "--check" ]]; then
  MODE="check"
fi

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
CANONICAL="$ROOT/.agents/skills"
LEGACY="$ROOT/skills"
CLAUDE_LINK="$ROOT/.claude/skills"
CURSOR_LINK="$ROOT/.cursor/skills"
GEMINI_DIR="$ROOT/.gemini/commands"

fail() {
  echo "ERROR: $*" >&2
  exit 1
}

ensure_symlink() {
  local link_path="$1"
  local target_rel="$2"

  if [[ "$MODE" == "check" ]]; then
    [[ -L "$link_path" ]] || fail "$link_path is not a symlink"
    local actual
    actual="$(readlink "$link_path")"
    [[ "$actual" == "$target_rel" ]] || fail "$link_path points to '$actual' (expected '$target_rel')"
    return
  fi

  mkdir -p "$(dirname "$link_path")"
  rm -rf "$link_path"
  ln -s "$target_rel" "$link_path"
}

parse_frontmatter_field() {
  local skill_file="$1"
  local field="$2"
  awk -v field="$field" '
    BEGIN { in_fm=0; fm_seen=0 }
    /^---[[:space:]]*$/ {
      if (fm_seen == 0) { in_fm=1; fm_seen=1; next }
      if (in_fm == 1) { in_fm=0; next }
    }
    in_fm == 1 {
      pat = "^" field ":[[:space:]]*"
      if ($0 ~ pat) {
        sub(pat, "", $0)
        gsub(/^"|"$/, "", $0)
        print $0
        exit
      }
    }
  ' "$skill_file"
}

[[ -d "$CANONICAL" ]] || fail "Canonical skills dir missing: $CANONICAL"

if [[ "$MODE" == "check" ]]; then
  [[ -L "$LEGACY" ]] || fail "$LEGACY is not a symlink"
  [[ "$(readlink "$LEGACY")" == ".agents/skills" ]] || fail "$LEGACY should point to .agents/skills"
else
  if [[ -d "$LEGACY" && ! -L "$LEGACY" ]]; then
    fail "Refusing to overwrite non-symlink $LEGACY. Migrate manually first."
  fi
  rm -rf "$LEGACY"
  ln -s .agents/skills "$LEGACY"
fi

ensure_symlink "$CLAUDE_LINK" "../.agents/skills"
ensure_symlink "$CURSOR_LINK" "../.agents/skills"

mkdir -p "$GEMINI_DIR"

# In apply mode, clean stale wrappers before regenerating
if [[ "$MODE" != "check" ]]; then
  rm -f "$GEMINI_DIR"/*.toml
fi

# Generate command wrappers from invocable skills.
skill_count=0
while IFS= read -r skill_file; do
  [[ -n "$skill_file" ]] || continue
  skill_dir="$(dirname "$skill_file")"
  skill_name="$(basename "$skill_dir")"

  # Skip non-invocable skills (e.g., deploy)
  invocable="$(parse_frontmatter_field "$skill_file" "user-invocable")"
  if [[ "$invocable" == "false" ]]; then
    continue
  fi

  desc="$(parse_frontmatter_field "$skill_file" "description")"
  if [[ -z "$desc" ]]; then
    desc="Run the $skill_name project skill from .agents/skills."
  fi

  out_file="$GEMINI_DIR/$skill_name.toml"
  if [[ "$MODE" == "check" ]]; then
    [[ -f "$out_file" ]] || fail "Missing Gemini wrapper: $out_file"
  else
    cat > "$out_file" <<TOML
# Generated by scripts/sync-agent-skills.sh. Do not edit manually.
description = "$desc"
prompt = """
Use the canonical project skill at .agents/skills/$skill_name/SKILL.md.

Follow that skill exactly, then execute the requested task.
If the user passed command arguments, incorporate them here: {{args}}
"""
TOML
  fi

  skill_count=$((skill_count + 1))
done < <(find "$CANONICAL" -mindepth 2 -maxdepth 2 -name SKILL.md | LC_ALL=C sort)

if [[ "$MODE" == "check" ]]; then
  wrapper_count="$(find "$GEMINI_DIR" -maxdepth 1 -name '*.toml' | wc -l | tr -d ' ')"
  [[ "$wrapper_count" -ge "$skill_count" ]] || fail "Gemini wrapper count ($wrapper_count) < skills ($skill_count)"
  echo "skills-check: OK ($skill_count skills, $wrapper_count gemini wrappers)"
else
  echo "skills-sync: OK ($skill_count skills synced)"
fi
